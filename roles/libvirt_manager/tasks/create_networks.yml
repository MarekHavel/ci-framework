---
# Copyright Red Hat, Inc.
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.


- name: Define the localized variables for performing the tasks here.
  vars:
    _fixed_names: >-
      {{
        cifmw_libvirt_manager_fixed_networks_defaults +
        cifmw_libvirt_manager_fixed_networks
      }}
    data:
      name: >-
        {{
          (cifmw_libvirt_manager_net_prefix_add | bool and
           item.key not in _fixed_names) |
          ternary('cifmw-' + item.key, item.key)
        }}
      xml: >-
        {{
          (cifmw_libvirt_manager_net_prefix_add | bool and
           item.key not in _fixed_names) |
          ternary(
            item.value | replace(item.key, 'cifmw-' ~ item.key),
            item.value
          )
        }}
  ansible.builtin.set_fact:
    networks: "{{ (networks | default([])) + [data] }}"
  loop: "{{ _cifmw_libvirt_manager_layout.networks | dict2items }}"
  loop_control:
    label: "{{ item.key }}"


- name: Ensure networks are defined
  community.libvirt.virt_net:
    command: define
    name: "{{ item.name }}"
    xml: "{{ item.xml }}"
    uri: "qemu:///system"
  loop: "{{ networks }}"
  loop_control:
    label: "{{ item.name }}"

- name: Ensure networks are created/started
  community.libvirt.virt_net:
    command: create
    name: "{{ item.name }}"
    uri: "qemu:///system"
  loop: "{{ networks }}"
  loop_control:
    label: "{{ item.name }}"

- name: Ensure networks are active
  community.libvirt.virt_net:
    state: active
    name: "{{ item.name }}"
    uri: "qemu:///system"
  loop: "{{ networks }}"
  loop_control:
    label: "{{ item.name }}"

- name: Ensure networks enabled to autostart
  community.libvirt.virt_net:
    autostart: true
    name: "{{ item.name }}"
    uri: "qemu:///system"
  loop: "{{ networks }}"
  loop_control:
    label: "{{ item.name }}"

## Ensure we get dnsmasq DHCP service for all created networks
# Refreshing network facts will ensure we get the new interfaces.
# They (usually?) have the same name as the network itself.
- name: Refresh networking facts on host
  ansible.builtin.setup:
    gather_subset:
      - '!all,!min'
      - network

- name: Build needed network related content
  when:
    - ansible_facts[_name] is defined
  vars:
    _name: "{{ item | replace('-', '_') }}"
    _no_prefix_name: "{{ _name | regex_replace('cifmw[-_]','') }}"
    _fixed_nets: >-
      {{
        cifmw_libvirt_manager_fixed_networks_defaults +
        cifmw_libvirt_manager_fixed_networks
      }}
    _dns_options: |-
      {% if ansible_facts[_name].ipv4 is defined -%}
      - "option:dns-server,{{ ansible_facts[_name].ipv4.address }}"
      {% endif -%}
      {% if ansible_facts[_name].ipv6 is defined -%}
      - "option6:dns-server,[{{ ansible_facts[_name].ipv6.address }}]"
      {% endif -%}
    _dns_listener:
      - "{{ ansible_facts[_name].ipv4.address | default('') }}"
      - "{{ ansible_facts[_name].ipv6.address | default('') }}"
    _dns_addr: |-
      {% if _no_prefix_name is match('^[a-z0-9]bm$')%}
      {%   if ansible_facts[_name].ipv4 is defined %}
      - fqdn: api.osasinfra.openstack.lab
        address: "{{ ansible_facts[_name].ipv4.address | ansible.utils.nthhost(5) }}"
      - fqdn: .apps.osasinfra.openstack.lab
        address: "{{ ansible_facts[_name].ipv4.address | ansible.utils.nthhost(6) }}"
      {%   endif %}
      {%   if ansible_facts[_name].ipv6 is defined %}
      - fqdn: api.osasinfra.openstack.lab
        address: "{{ ansible_facts[_name].ipv6.address | ansible.utils.nthhost(5) }}"
      - fqdn: .apps.osasinfra.openstack.lab
        address: "{{ ansible_facts[_name].ipv6.address | ansible.utils.nthhost(6) }}"
      {%   endif %}
      {% endif%}
    _local_net_info:
      - name: "{{ _no_prefix_name }}"
        original_name: "{{ item }}"
        ranges:
          - label: "{{ _no_prefix_name }}"
            start_v4: >-
              {%- if ansible_facts[_name].ipv4 is defined -%}
              {{ ansible_facts[_name].ipv4.address | ansible.utils.ipmath(1) }}
              {%- endif -%}
            prefix_length_v4: >-
              {%- if ansible_facts[_name].ipv4 is defined -%}
              {{ ansible_facts[_name].ipv4.prefix }}
              {%- endif -%}
            start_v6: >-
              {%- if ansible_facts[_name].ipv6 is defined -%}
              {{ ansible_facts[_name].ipv6.address | ansible.utils.ipmath(1) }}
              {%- endif -%}
            prefix_length_v6: >-
              {%- if ansible_facts[_name].ipv6 is defined -%}
              {{ ansible_facts[_name].ipv6.prefix }}
              {%- endif -%}
            options: "{{ _dns_options | from_yaml }}"
  ansible.builtin.set_fact:
    _network_data: "{{ _network_data | default([]) + _local_net_info }}"
    _dns_listeners: >-
      {{ _dns_listeners | default({}) | combine({_name: _dns_listener}) }}
    _dns_addresses: >-
      {{ _dns_addresses | default({}) | combine({_name: _dns_addr}) }}
  loop: "{{ (networks | map(attribute='name') | flatten) + _fixed_nets }}"

- name: Create dnsmasq network
  when:
    - item.original_name not in _no_dnsmasq
  vars:
    _no_dnsmasq: >-
      {{
        cifmw_libvirt_manager_no_dnsmasq_nets_defaults +
        cifmw_libvirt_manager_no_dnsmasq_nets
      }}
    cifmw_dnsmasq_network_name: "{{ item.name }}"
    cifmw_dnsmasq_network_state: present
    cifmw_dnsmasq_network_definition: "{{ item }}"
    cifmw_dnsmasq_network_listen_dns: "{{ _dns_address[item.name] }}"
    cifmw_dnsmasq_network_dns_entries: "{{ _dns_addresses | from_yaml }}"
  ansible.builtin.include_role:
    name: dnsmasq
    tasks_from: manage_network.yml
  loop: "{{ _network_data }}"
  loop_control:
    label: "{{ item.name }}"

- name: Ensure dnsmasq listens on correct interfaces
  vars:
    cifmw_dnsmasq_bind_interfaces: >-
      {{
        _network_data | map(attribute='original_name') | flatten
      }}
  ansible.builtin.include_role:
    name: dnsmasq
    tasks_from: manage_listen.yml

- name: Gather the status of firewall service.
  become: true
  ansible.builtin.service:
    name: firewalld
  register: _fw_info

- name: Ensure network is in libvirt zone
  become: true
  when:
    - _fw_info.status.SubState | default('') == "running"
  ansible.posix.firewalld:
    zone: libvirt
    interface: "{{ item }}"
    state: enabled
    permanent: true
    immediate: true
  loop: "{{ networks | map(attribute='name') | flatten | unique }}"
  loop_control:
    label: "{{ item }}"
